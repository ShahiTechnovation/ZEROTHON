"""
${contractName || 'MyContract'} - Generated by Zero Wizard
Contract Type: ${CONTRACT_TYPES.find(t => t.id === contractType)?.name || 'Contract'}
Modules: ${Array.from(selectedModules).map(id => MODULES.find(m => m.id === id)?.name).filter(Boolean).join(', ') || 'None'}

Security: âœ“ Compiler-compatible
Generated: ${new Date().toISOString()}
"""

from zerothan.py_contracts import PySmartContract

class ${contractName || 'MyContract'}(PySmartContract):
    """
    ${CONTRACT_TYPES.find(t => t.id === contractType)?.description || 'Smart contract'}
    
    Features:
${Array.from(selectedModules).map(id => {
    const module = MODULES.find(m => m.id === id)
    return module ? `    - ${module.name}: ${module.description}` : ''
}).filter(Boolean).join('\n')}
    """
    
    def __init__(self):
        super().__init__()
        
${contractType === 'token' ? `        # Token metadata
        self.name = "${contractName || 'MyToken'}"
        self.symbol = "${contractSymbol || 'TKN'}"
        self.decimals = ${decimals}
        
        # State variables
        self.total_supply = self.state_var("total_supply", 0)
        self.balances = self.state_var("balances", {})
${!selectedModules.has('mintable') && initialSupply ? `        
        # Set initial supply
        self.total_supply = ${initialSupply} * 10**${decimals}
        self.balances[self.msg_sender()] = self.total_supply` : ''}` : ''}${contractType === 'nft' ? `        # NFT metadata
        self.name = "${contractName || 'MyNFT'}"
        self.symbol = "${contractSymbol || 'NFT'}"
        
        # State variables
        self.owners = self.state_var("owners", {})
        self.balances = self.state_var("balances", {})
        self.token_approvals = self.state_var("token_approvals", {})
        self.next_token_id = self.state_var("next_token_id", 1)` : ''}${contractType === 'vault' ? `        # Vault state
        self.deposits = self.state_var("deposits", {})
        self.total_deposited = self.state_var("total_deposited", 0)` : ''}${selectedModules.has('ownable') ? `        
        # Ownable
        self.owner = self.state_var("owner", self.msg_sender())` : ''}${selectedModules.has('pausable') ? `        
        # Pausable
        self.paused = self.state_var("paused", False)` : ''}${contractType === 'token' && initialSupply && selectedModules.has('mintable') ? `        
        # Mint initial supply
        initial_amount = ${initialSupply} * 10**${decimals}
        self.balances[self.msg_sender()] = initial_amount
        self.total_supply = initial_amount` : ''}
${contractType === 'token' ? `
    @public_function
    def transfer(self, to: str, amount: int):
        """Transfer tokens to another address."""
        sender = self.msg_sender()
${selectedModules.has('pausable') ? `        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
` : ''}        
        sender_bal = self.balances.get(sender, 0)
        if sender_bal < amount:
            raise Exception("Insufficient balance")
        
        recipient_bal = self.balances.get(to, 0)
        self.balances[sender] = sender_bal - amount
        self.balances[to] = recipient_bal + amount
        
        self.event("Transfer", sender, to, amount)

    @view_function
    def balance_of(self, owner: str) -> int:
        """Get the balance of an address."""
        return self.balances.get(owner, 0)

    @view_function
    def get_total_supply(self) -> int:
        """Get total supply."""
        return self.total_supply
${selectedModules.has('mintable') ? `
    @public_function
    def mint(self, to: str, amount: int):
        """Mint new tokens (Admin only)."""
        sender = self.msg_sender()
${selectedModules.has('ownable') ? `        
        # Only owner can mint
        if sender != self.owner:
            raise Exception("Only owner can mint")
` : ''}${selectedModules.has('pausable') ? `        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
` : ''}        
        current_bal = self.balances.get(to, 0)
        self.balances[to] = current_bal + amount
        self.total_supply += amount
        
        self.event("Transfer", "0x0000000000000000000000000000000000000000", to, amount)
        self.event("Mint", to, amount)` : ''}${selectedModules.has('burnable') ? `
    @public_function
    def burn(self, amount: int):
        """Burn your own tokens."""
        sender = self.msg_sender()
        sender_bal = self.balances.get(sender, 0)
        
        if sender_bal < amount:
            raise Exception("Insufficient balance to burn")
        
        self.balances[sender] = sender_bal - amount
        self.total_supply -= amount
        
        self.event("Transfer", sender, "0x0000000000000000000000000000000000000000", amount)
        self.event("Burn", sender, amount)` : ''}` : ''}${contractType === 'nft' && selectedModules.has('mintable') ? `
    @public_function
    def mint(self, to: str) -> int:
        """Mint a new NFT."""
        sender = self.msg_sender()
${selectedModules.has('ownable') ? `        
        # Only owner can mint
        if sender != self.owner:
            raise Exception("Only owner can mint")
` : ''}        
        token_id = self.next_token_id
        self.next_token_id += 1
        
        self.owners[token_id] = to
        self.balances[to] = self.balances.get(to, 0) + 1
        
        self.event("Transfer", "0x0000000000000000000000000000000000000000", to, token_id)
        return token_id

    @view_function
    def owner_of(self, token_id: int) -> str:
        """Get owner of a token."""
        owner = self.owners.get(token_id)
        if not owner:
            raise Exception("Token does not exist")
        return owner` : ''}${contractType === 'vault' ? `
    @public_function
    def deposit(self, amount: int):
        """Deposit funds into the vault."""
        sender = self.msg_sender()
${selectedModules.has('pausable') ? `        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
` : ''}        
        if amount <= 0:
            raise Exception("Amount must be positive")
        
        current_deposit = self.deposits.get(sender, 0)
        self.deposits[sender] = current_deposit + amount
        self.total_deposited += amount
        
        self.event("Deposit", sender, amount)

    @public_function
    def withdraw(self, amount: int):
        """Withdraw funds from the vault."""
        sender = self.msg_sender()
${selectedModules.has('pausable') ? `        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
` : ''}        
        current_deposit = self.deposits.get(sender, 0)
        if current_deposit < amount:
            raise Exception("Insufficient balance")
        
        self.deposits[sender] = current_deposit - amount
        self.total_deposited -= amount
        
        self.event("Withdrawal", sender, amount)

    @view_function
    def get_balance(self, account: str) -> int:
        """Get vault balance for an account."""
        return self.deposits.get(account, 0)` : ''}${selectedModules.has('pausable') ? `
    @public_function
    def pause(self):
        """Pause contract operations."""
        sender = self.msg_sender()
${selectedModules.has('ownable') ? `        
        # Only owner can pause
        if sender != self.owner:
            raise Exception("Only owner can pause")
` : ''}        
        if self.paused:
            raise Exception("Already paused")
        
        self.paused = True
        self.event("Paused", sender)

    @public_function
    def unpause(self):
        """Unpause contract operations."""
        sender = self.msg_sender()
${selectedModules.has('ownable') ? `        
        # Only owner can unpause
        if sender != self.owner:
            raise Exception("Only owner can unpause")
` : ''}        
        if not self.paused:
            raise Exception("Not paused")
        
        self.paused = False
        self.event("Unpaused", sender)` : ''}
