"""
AdvancedNFT - Full-Featured ERC721 NFT Collection
Generated by Zero Wizard - Production Ready

Features:
- Complete ERC721 implementation
- Ownable (single owner access control)
- Mintable with auto-incrementing IDs
- Burnable (destroy NFTs)
- Pausable (emergency pause)
- Metadata URI support
- Approval system (single + operator)
- Royalty tracking
- Collection management
"""

from zerothan.py_contracts import PySmartContract

class AdvancedNFT(PySmartContract):
    """
    Advanced ERC721-equivalent NFT collection with comprehensive features.
    
    This contract includes:
    - Full ERC721 standard (transfer, approve, setApprovalForAll)
    - Metadata URI management
    - Owner-controlled minting
    - Token burning
    - Emergency pause mechanism
    - Royalty information
    - Collection statistics
    """
    
    def __init__(self):
        super().__init__()
        
        # Collection metadata
        self.name = "Advanced NFT Collection"
        self.symbol = "ANFT"
        self.base_uri = self.state_var("base_uri", "")
        
        # Core NFT state
        self.owners = self.state_var("owners", {})  # token_id -> owner
        self.balances = self.state_var("balances", {})  # owner -> count
        self.token_approvals = self.state_var("token_approvals", {})  # token_id -> approved
        self.operator_approvals = self.state_var("operator_approvals", {})  # owner -> {operator -> bool}
        
        # Token metadata
        self.token_uris = self.state_var("token_uris", {})  # token_id -> URI
        
        # Minting control
        self.next_token_id = self.state_var("next_token_id", 1)
        self.max_supply = self.state_var("max_supply", 10000)
        self.minting_enabled = self.state_var("minting_enabled", True)
        
        # Ownable state
        self.owner = self.state_var("owner", self.msg_sender())
        
        # Pausable state
        self.paused = self.state_var("paused", False)
        
        # Royalty info (percentage in basis points, e.g., 500 = 5%)
        self.royalty_percentage = self.state_var("royalty_percentage", 500)  # 5%
        self.royalty_receiver = self.state_var("royalty_receiver", self.msg_sender())
        
        # Statistics
        self.total_minted = self.state_var("total_minted", 0)
        self.total_burned = self.state_var("total_burned", 0)
        self.total_transfers = self.state_var("total_transfers", 0)

    # ============================================
    # ERC721 CORE FUNCTIONS
    # ============================================

    @public_function
    def transfer_from(self, from_addr: str, to: str, token_id: int):
        """
        Transfer an NFT from one address to another.
        
        Requirements:
        - Contract must not be paused
        - Caller must be owner or approved
        - Token must exist
        - Cannot transfer to zero address
        """
        sender = self.msg_sender()
        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
        
        # Check if token exists
        owner = self.owners.get(token_id)
        if not owner:
            raise Exception("Token does not exist")
        
        # Check ownership
        if owner != from_addr:
            raise Exception("From address is not the owner")
        
        # Check authorization
        if sender != owner:
            # Check single token approval
            approved = self.token_approvals.get(token_id)
            is_approved = (approved == sender)
            
            # Check operator approval
            if not is_approved:
                if owner in self.operator_approvals:
                    is_approved = self.operator_approvals[owner].get(sender, False)
            
            if not is_approved:
                raise Exception("Not authorized to transfer")
        
        # Check recipient
        if to == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot transfer to zero address")
        
        # Clear approvals
        if token_id in self.token_approvals:
            del self.token_approvals[token_id]
        
        # Update balances
        self.balances[from_addr] -= 1
        self.balances[to] = self.balances.get(to, 0) + 1
        
        # Update owner
        self.owners[token_id] = to
        
        # Update statistics
        self.total_transfers += 1
        
        self.event("Transfer", from_addr, to, token_id)

    @public_function
    def safe_transfer_from(self, from_addr: str, to: str, token_id: int):
        """
        Safely transfer an NFT (same as transfer_from in Python context).
        """
        self.transfer_from(from_addr, to, token_id)

    @public_function
    def approve(self, to: str, token_id: int):
        """
        Approve an address to transfer a specific NFT.
        
        Requirements:
        - Caller must be owner or operator
        - Cannot approve to current owner
        """
        sender = self.msg_sender()
        owner = self.owners.get(token_id)
        
        if not owner:
            raise Exception("Token does not exist")
        
        if to == owner:
            raise Exception("Cannot approve to current owner")
        
        # Check authorization
        is_authorized = (sender == owner)
        if not is_authorized and owner in self.operator_approvals:
            is_authorized = self.operator_approvals[owner].get(sender, False)
        
        if not is_authorized:
            raise Exception("Not authorized to approve")
        
        self.token_approvals[token_id] = to
        self.event("Approval", owner, to, token_id)

    @public_function
    def set_approval_for_all(self, operator: str, approved: int):
        """
        Enable or disable approval for a third party to manage all NFTs.
        
        Args:
            operator: Address to set approval for
            approved: 1 for true, 0 for false
        """
        sender = self.msg_sender()
        
        if operator == sender:
            raise Exception("Cannot approve yourself")
        
        if operator == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot approve zero address")
        
        # Initialize nested dict if needed
        if sender not in self.operator_approvals:
            self.operator_approvals[sender] = {}
        
        is_approved = (approved == 1)
        self.operator_approvals[sender][operator] = is_approved
        
        self.event("ApprovalForAll", sender, operator, approved)

    # ============================================
    # VIEW FUNCTIONS
    # ============================================

    @view_function
    def balance_of(self, owner: str) -> int:
        """Get the number of NFTs owned by an address."""
        if owner == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot query zero address")
        return self.balances.get(owner, 0)

    @view_function
    def owner_of(self, token_id: int) -> str:
        """Get the owner of a specific NFT."""
        owner = self.owners.get(token_id)
        if not owner:
            raise Exception("Token does not exist")
        return owner

    @view_function
    def get_approved(self, token_id: int) -> str:
        """Get the approved address for a specific NFT."""
        if token_id not in self.owners:
            raise Exception("Token does not exist")
        
        approved = self.token_approvals.get(token_id)
        if not approved:
            return "0x0000000000000000000000000000000000000000"
        return approved

    @view_function
    def is_approved_for_all(self, owner: str, operator: str) -> int:
        """Check if an operator is approved to manage all NFTs of an owner."""
        if owner not in self.operator_approvals:
            return 0
        is_approved = self.operator_approvals[owner].get(operator, False)
        return 1 if is_approved else 0

    @view_function
    def token_uri(self, token_id: int) -> str:
        """Get metadata URI for a token."""
        if token_id not in self.owners:
            raise Exception("Token does not exist")
        
        # Check for specific token URI
        if token_id in self.token_uris:
            return self.token_uris[token_id]
        
        # Fall back to base URI + token ID
        # Note: In Python, we return empty string if no base URI
        return self.base_uri

    @view_function
    def total_supply(self) -> int:
        """Get the total number of NFTs in existence."""
        return self.total_minted - self.total_burned

    @view_function
    def get_owner(self) -> str:
        """Get the contract owner."""
        return self.owner

    @view_function
    def is_paused(self) -> int:
        """Check if contract is paused."""
        return 1 if self.paused else 0

    @view_function
    def get_max_supply(self) -> int:
        """Get the maximum supply."""
        return self.max_supply

    @view_function
    def get_total_minted(self) -> int:
        """Get total number of NFTs ever minted."""
        return self.total_minted

    @view_function
    def get_total_burned(self) -> int:
        """Get total number of NFTs ever burned."""
        return self.total_burned

    @view_function
    def get_total_transfers(self) -> int:
        """Get total number of transfers."""
        return self.total_transfers

    # ============================================
    # MINTING FUNCTIONS
    # ============================================

    @public_function
    def mint(self, to: str) -> int:
        """
        Mint a new NFT (Owner only).
        
        Returns the token ID of the minted NFT.
        """
        sender = self.msg_sender()
        
        # Only owner can mint
        if sender != self.owner:
            raise Exception("Only owner can mint")
        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
        
        # Check if minting is enabled
        if not self.minting_enabled:
            raise Exception("Minting is disabled")
        
        # Check recipient
        if to == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot mint to zero address")
        
        # Check max supply
        current_supply = self.total_minted - self.total_burned
        if current_supply >= self.max_supply:
            raise Exception("Max supply reached")
        
        # Mint token
        token_id = self.next_token_id
        self.next_token_id += 1
        
        self.owners[token_id] = to
        self.balances[to] = self.balances.get(to, 0) + 1
        self.total_minted += 1
        
        self.event("Transfer", "0x0000000000000000000000000000000000000000", to, token_id)
        self.event("Mint", to, token_id)
        
        return token_id

    @public_function
    def mint_with_uri(self, to: str, uri: str) -> int:
        """
        Mint a new NFT with a specific metadata URI (Owner only).
        
        Returns the token ID of the minted NFT.
        """
        sender = self.msg_sender()
        
        # Only owner can mint
        if sender != self.owner:
            raise Exception("Only owner can mint")
        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
        
        # Check if minting is enabled
        if not self.minting_enabled:
            raise Exception("Minting is disabled")
        
        # Check recipient
        if to == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot mint to zero address")
        
        # Check max supply
        current_supply = self.total_minted - self.total_burned
        if current_supply >= self.max_supply:
            raise Exception("Max supply reached")
        
        # Mint token
        token_id = self.next_token_id
        self.next_token_id += 1
        
        self.owners[token_id] = to
        self.balances[to] = self.balances.get(to, 0) + 1
        self.token_uris[token_id] = uri
        self.total_minted += 1
        
        self.event("Transfer", "0x0000000000000000000000000000000000000000", to, token_id)
        self.event("Mint", to, token_id)
        
        return token_id

    @public_function
    def disable_minting(self):
        """
        Permanently disable minting (Owner only).
        This action cannot be undone!
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can disable minting")
        
        self.minting_enabled = False
        self.event("MintingDisabled", sender)

    # ============================================
    # BURNING FUNCTIONS
    # ============================================

    @public_function
    def burn(self, token_id: int):
        """
        Burn an NFT.
        
        Requirements:
        - Caller must be owner or approved
        - Token must exist
        """
        sender = self.msg_sender()
        
        # Check if token exists
        owner = self.owners.get(token_id)
        if not owner:
            raise Exception("Token does not exist")
        
        # Check authorization
        if sender != owner:
            # Check single token approval
            approved = self.token_approvals.get(token_id)
            is_approved = (approved == sender)
            
            # Check operator approval
            if not is_approved and owner in self.operator_approvals:
                is_approved = self.operator_approvals[owner].get(sender, False)
            
            if not is_approved:
                raise Exception("Not authorized to burn")
        
        # Clear approvals
        if token_id in self.token_approvals:
            del self.token_approvals[token_id]
        
        # Clear metadata
        if token_id in self.token_uris:
            del self.token_uris[token_id]
        
        # Update balances
        self.balances[owner] -= 1
        
        # Remove ownership
        del self.owners[token_id]
        
        # Update statistics
        self.total_burned += 1
        
        self.event("Transfer", owner, "0x0000000000000000000000000000000000000000", token_id)
        self.event("Burn", owner, token_id)

    # ============================================
    # METADATA FUNCTIONS
    # ============================================

    @public_function
    def set_base_uri(self, uri: str):
        """
        Set the base URI for all tokens (Owner only).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set base URI")
        
        self.base_uri = uri
        self.event("BaseURISet", uri)

    @public_function
    def set_token_uri(self, token_id: int, uri: str):
        """
        Set a specific URI for a token (Owner only).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set token URI")
        
        if token_id not in self.owners:
            raise Exception("Token does not exist")
        
        self.token_uris[token_id] = uri
        self.event("TokenURISet", token_id, uri)

    # ============================================
    # PAUSABLE FUNCTIONS
    # ============================================

    @public_function
    def pause(self):
        """Pause all NFT transfers (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can pause")
        
        if self.paused:
            raise Exception("Already paused")
        
        self.paused = True
        self.event("Paused", sender)

    @public_function
    def unpause(self):
        """Unpause NFT transfers (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can unpause")
        
        if not self.paused:
            raise Exception("Not paused")
        
        self.paused = False
        self.event("Unpaused", sender)

    # ============================================
    # ROYALTY FUNCTIONS
    # ============================================

    @public_function
    def set_royalty_info(self, receiver: str, percentage: int):
        """
        Set royalty information (Owner only).
        
        Args:
            receiver: Address to receive royalties
            percentage: Royalty percentage in basis points (e.g., 500 = 5%)
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set royalty info")
        
        if percentage > 10000:  # Max 100%
            raise Exception("Royalty percentage too high")
        
        self.royalty_receiver = receiver
        self.royalty_percentage = percentage
        self.event("RoyaltyInfoSet", receiver, percentage)

    @view_function
    def get_royalty_info(self) -> int:
        """Get royalty percentage (in basis points)."""
        return self.royalty_percentage

    @view_function
    def get_royalty_receiver(self) -> str:
        """Get royalty receiver address."""
        return self.royalty_receiver

    # ============================================
    # OWNERSHIP FUNCTIONS
    # ============================================

    @public_function
    def transfer_ownership(self, new_owner: str):
        """Transfer ownership to a new address (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can transfer ownership")
        
        if new_owner == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot transfer to zero address")
        
        old_owner = self.owner
        self.owner = new_owner
        self.event("OwnershipTransferred", old_owner, new_owner)

    @public_function
    def renounce_ownership(self):
        """
        Renounce ownership (Owner only).
        WARNING: This will leave the contract without an owner!
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can renounce ownership")
        
        old_owner = self.owner
        self.owner = "0x0000000000000000000000000000000000000000"
        self.event("OwnershipRenounced", old_owner)
