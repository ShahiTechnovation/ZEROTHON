"""
AdvancedVault - Full-Featured Secure Vault/Escrow Contract
Generated by Zero Wizard - Production Ready

Features:
- Secure deposit and withdrawal system
- Time-locked withdrawals
- Multi-user support
- Emergency withdrawal
- Pausable operations
- Withdrawal limits
- Fee system
- Detailed tracking and statistics
"""

from zerothan.py_contracts import PySmartContract

class AdvancedVault(PySmartContract):
    """
    Advanced vault contract for secure asset management.
    
    This contract includes:
    - Deposit and withdrawal functionality
    - Time-locked withdrawals for security
    - Withdrawal limits per user
    - Emergency pause mechanism
    - Fee collection system
    - Comprehensive statistics and tracking
    """
    
    def __init__(self):
        super().__init__()
        
        # Core vault state
        self.deposits = self.state_var("deposits", {})  # user -> amount
        self.deposit_times = self.state_var("deposit_times", {})  # user -> block number
        self.total_deposited = self.state_var("total_deposited", 0)
        self.total_withdrawn = self.state_var("total_withdrawn", 0)
        
        # Withdrawal limits
        self.withdrawal_limits = self.state_var("withdrawal_limits", {})  # user -> limit
        self.default_withdrawal_limit = self.state_var("default_withdrawal_limit", 1000000 * 10**18)
        
        # Time lock (in blocks)
        self.lock_duration = self.state_var("lock_duration", 100)  # 100 blocks
        self.withdrawal_requests = self.state_var("withdrawal_requests", {})  # user -> {amount, block}
        
        # Fee system (in basis points, e.g., 100 = 1%)
        self.deposit_fee = self.state_var("deposit_fee", 0)  # No deposit fee by default
        self.withdrawal_fee = self.state_var("withdrawal_fee", 50)  # 0.5% withdrawal fee
        self.collected_fees = self.state_var("collected_fees", 0)
        
        # Ownable state
        self.owner = self.state_var("owner", self.msg_sender())
        
        # Pausable state
        self.paused = self.state_var("paused", False)
        
        # Emergency mode
        self.emergency_mode = self.state_var("emergency_mode", False)
        
        # Statistics
        self.total_depositors = self.state_var("total_depositors", 0)
        self.total_deposit_count = self.state_var("total_deposit_count", 0)
        self.total_withdrawal_count = self.state_var("total_withdrawal_count", 0)
        
        # Whitelist/Blacklist
        self.whitelist_enabled = self.state_var("whitelist_enabled", False)
        self.whitelist = self.state_var("whitelist", {})
        self.blacklist = self.state_var("blacklist", {})

    # ============================================
    # DEPOSIT FUNCTIONS
    # ============================================

    @public_function
    def deposit(self, amount: int):
        """
        Deposit funds into the vault.
        
        Requirements:
        - Contract must not be paused
        - Amount must be positive
        - User must not be blacklisted
        - If whitelist enabled, user must be whitelisted
        """
        sender = self.msg_sender()
        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
        
        # Check emergency mode
        if self.emergency_mode:
            raise Exception("Emergency mode active - deposits disabled")
        
        # Check amount
        if amount <= 0:
            raise Exception("Amount must be positive")
        
        # Check blacklist
        if self.blacklist.get(sender, False):
            raise Exception("Address is blacklisted")
        
        # Check whitelist
        if self.whitelist_enabled and not self.whitelist.get(sender, False):
            raise Exception("Address not whitelisted")
        
        # Calculate fee
        fee = (amount * self.deposit_fee) // 10000
        amount_after_fee = amount - fee
        
        # Update deposits
        current_deposit = self.deposits.get(sender, 0)
        was_new_depositor = (current_deposit == 0)
        
        self.deposits[sender] = current_deposit + amount_after_fee
        self.deposit_times[sender] = self.block_number()
        self.total_deposited += amount_after_fee
        self.collected_fees += fee
        
        # Update statistics
        if was_new_depositor:
            self.total_depositors += 1
        self.total_deposit_count += 1
        
        self.event("Deposit", sender, amount, amount_after_fee, fee)

    @public_function
    def deposit_for(self, beneficiary: str, amount: int):
        """
        Deposit funds on behalf of another address.
        
        Requirements:
        - Same as regular deposit
        - Beneficiary cannot be zero address
        """
        sender = self.msg_sender()
        
        # Check beneficiary
        if beneficiary == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot deposit for zero address")
        
        # Check if paused
        if self.paused:
            raise Exception("Contract is paused")
        
        # Check emergency mode
        if self.emergency_mode:
            raise Exception("Emergency mode active - deposits disabled")
        
        # Check amount
        if amount <= 0:
            raise Exception("Amount must be positive")
        
        # Check blacklist (both sender and beneficiary)
        if self.blacklist.get(sender, False):
            raise Exception("Sender is blacklisted")
        
        if self.blacklist.get(beneficiary, False):
            raise Exception("Beneficiary is blacklisted")
        
        # Calculate fee
        fee = (amount * self.deposit_fee) // 10000
        amount_after_fee = amount - fee
        
        # Update deposits
        current_deposit = self.deposits.get(beneficiary, 0)
        was_new_depositor = (current_deposit == 0)
        
        self.deposits[beneficiary] = current_deposit + amount_after_fee
        self.deposit_times[beneficiary] = self.block_number()
        self.total_deposited += amount_after_fee
        self.collected_fees += fee
        
        # Update statistics
        if was_new_depositor:
            self.total_depositors += 1
        self.total_deposit_count += 1
        
        self.event("DepositFor", sender, beneficiary, amount, amount_after_fee, fee)

    # ============================================
    # WITHDRAWAL FUNCTIONS
    # ============================================

    @public_function
    def request_withdrawal(self, amount: int):
        """
        Request a withdrawal (will be time-locked).
        
        Requirements:
        - Contract must not be paused
        - User must have sufficient balance
        - Amount must not exceed withdrawal limit
        """
        sender = self.msg_sender()
        
        # Check if paused
        if self.paused and not self.emergency_mode:
            raise Exception("Contract is paused")
        
        # Check amount
        if amount <= 0:
            raise Exception("Amount must be positive")
        
        # Check balance
        current_deposit = self.deposits.get(sender, 0)
        if current_deposit < amount:
            raise Exception("Insufficient balance")
        
        # Check withdrawal limit
        user_limit = self.withdrawal_limits.get(sender, self.default_withdrawal_limit)
        if amount > user_limit:
            raise Exception("Amount exceeds withdrawal limit")
        
        # Create withdrawal request
        if sender not in self.withdrawal_requests:
            self.withdrawal_requests[sender] = {}
        
        self.withdrawal_requests[sender] = {
            "amount": amount,
            "block": self.block_number()
        }
        
        self.event("WithdrawalRequested", sender, amount, self.block_number() + self.lock_duration)

    @public_function
    def execute_withdrawal(self):
        """
        Execute a previously requested withdrawal.
        
        Requirements:
        - Must have an active withdrawal request
        - Lock duration must have passed
        """
        sender = self.msg_sender()
        
        # Check if withdrawal request exists
        if sender not in self.withdrawal_requests:
            raise Exception("No withdrawal request found")
        
        request = self.withdrawal_requests[sender]
        if "amount" not in request:
            raise Exception("Invalid withdrawal request")
        
        amount = request["amount"]
        request_block = request["block"]
        
        # Check if lock duration has passed
        if self.block_number() < request_block + self.lock_duration:
            raise Exception("Withdrawal still locked")
        
        # Check balance (in case it changed)
        current_deposit = self.deposits.get(sender, 0)
        if current_deposit < amount:
            raise Exception("Insufficient balance")
        
        # Calculate fee
        fee = (amount * self.withdrawal_fee) // 10000
        amount_after_fee = amount - fee
        
        # Update deposits
        self.deposits[sender] = current_deposit - amount
        self.total_withdrawn += amount_after_fee
        self.collected_fees += fee
        
        # Clear withdrawal request
        del self.withdrawal_requests[sender]
        
        # Update statistics
        self.total_withdrawal_count += 1
        
        self.event("Withdrawal", sender, amount, amount_after_fee, fee)

    @public_function
    def cancel_withdrawal(self):
        """
        Cancel a pending withdrawal request.
        """
        sender = self.msg_sender()
        
        # Check if withdrawal request exists
        if sender not in self.withdrawal_requests:
            raise Exception("No withdrawal request found")
        
        # Clear withdrawal request
        del self.withdrawal_requests[sender]
        
        self.event("WithdrawalCancelled", sender)

    @public_function
    def emergency_withdraw(self):
        """
        Emergency withdrawal (only available in emergency mode).
        Bypasses time lock but may have higher fees.
        """
        sender = self.msg_sender()
        
        # Check emergency mode
        if not self.emergency_mode:
            raise Exception("Emergency mode not active")
        
        # Get balance
        current_deposit = self.deposits.get(sender, 0)
        if current_deposit <= 0:
            raise Exception("No balance to withdraw")
        
        # Calculate emergency fee (double the normal withdrawal fee)
        emergency_fee_rate = self.withdrawal_fee * 2
        fee = (current_deposit * emergency_fee_rate) // 10000
        amount_after_fee = current_deposit - fee
        
        # Update deposits
        self.deposits[sender] = 0
        self.total_withdrawn += amount_after_fee
        self.collected_fees += fee
        
        # Clear any pending withdrawal request
        if sender in self.withdrawal_requests:
            del self.withdrawal_requests[sender]
        
        # Update statistics
        self.total_withdrawal_count += 1
        
        self.event("EmergencyWithdrawal", sender, current_deposit, amount_after_fee, fee)

    # ============================================
    # VIEW FUNCTIONS
    # ============================================

    @view_function
    def get_balance(self, account: str) -> int:
        """Get vault balance for an account."""
        return self.deposits.get(account, 0)

    @view_function
    def get_total_deposited(self) -> int:
        """Get total amount deposited in vault."""
        return self.total_deposited

    @view_function
    def get_total_withdrawn(self) -> int:
        """Get total amount withdrawn from vault."""
        return self.total_withdrawn

    @view_function
    def get_vault_balance(self) -> int:
        """Get current vault balance (deposits - withdrawals)."""
        return self.total_deposited - self.total_withdrawn

    @view_function
    def get_collected_fees(self) -> int:
        """Get total fees collected."""
        return self.collected_fees

    @view_function
    def get_withdrawal_limit(self, account: str) -> int:
        """Get withdrawal limit for an account."""
        return self.withdrawal_limits.get(account, self.default_withdrawal_limit)

    @view_function
    def get_lock_duration(self) -> int:
        """Get withdrawal lock duration in blocks."""
        return self.lock_duration

    @view_function
    def get_deposit_fee(self) -> int:
        """Get deposit fee in basis points."""
        return self.deposit_fee

    @view_function
    def get_withdrawal_fee(self) -> int:
        """Get withdrawal fee in basis points."""
        return self.withdrawal_fee

    @view_function
    def is_paused(self) -> int:
        """Check if contract is paused."""
        return 1 if self.paused else 0

    @view_function
    def is_emergency_mode(self) -> int:
        """Check if emergency mode is active."""
        return 1 if self.emergency_mode else 0

    @view_function
    def get_total_depositors(self) -> int:
        """Get total number of depositors."""
        return self.total_depositors

    @view_function
    def get_total_deposit_count(self) -> int:
        """Get total number of deposits."""
        return self.total_deposit_count

    @view_function
    def get_total_withdrawal_count(self) -> int:
        """Get total number of withdrawals."""
        return self.total_withdrawal_count

    @view_function
    def is_whitelisted(self, account: str) -> int:
        """Check if an address is whitelisted."""
        return 1 if self.whitelist.get(account, False) else 0

    @view_function
    def is_blacklisted(self, account: str) -> int:
        """Check if an address is blacklisted."""
        return 1 if self.blacklist.get(account, False) else 0

    # ============================================
    # OWNER FUNCTIONS - FEE MANAGEMENT
    # ============================================

    @public_function
    def set_deposit_fee(self, fee: int):
        """
        Set deposit fee (Owner only).
        Fee is in basis points (e.g., 100 = 1%).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set fees")
        
        if fee > 1000:  # Max 10%
            raise Exception("Fee too high")
        
        self.deposit_fee = fee
        self.event("DepositFeeSet", fee)

    @public_function
    def set_withdrawal_fee(self, fee: int):
        """
        Set withdrawal fee (Owner only).
        Fee is in basis points (e.g., 100 = 1%).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set fees")
        
        if fee > 1000:  # Max 10%
            raise Exception("Fee too high")
        
        self.withdrawal_fee = fee
        self.event("WithdrawalFeeSet", fee)

    @public_function
    def withdraw_fees(self, amount: int):
        """
        Withdraw collected fees (Owner only).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can withdraw fees")
        
        if amount > self.collected_fees:
            raise Exception("Insufficient fees collected")
        
        self.collected_fees -= amount
        self.event("FeesWithdrawn", sender, amount)

    # ============================================
    # OWNER FUNCTIONS - LIMITS & LOCKS
    # ============================================

    @public_function
    def set_default_withdrawal_limit(self, limit: int):
        """Set default withdrawal limit (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set limits")
        
        self.default_withdrawal_limit = limit
        self.event("DefaultWithdrawalLimitSet", limit)

    @public_function
    def set_user_withdrawal_limit(self, user: str, limit: int):
        """Set withdrawal limit for a specific user (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set limits")
        
        self.withdrawal_limits[user] = limit
        self.event("UserWithdrawalLimitSet", user, limit)

    @public_function
    def set_lock_duration(self, duration: int):
        """Set withdrawal lock duration in blocks (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can set lock duration")
        
        if duration > 100000:  # Max ~2 weeks at 12s blocks
            raise Exception("Lock duration too long")
        
        self.lock_duration = duration
        self.event("LockDurationSet", duration)

    # ============================================
    # OWNER FUNCTIONS - ACCESS CONTROL
    # ============================================

    @public_function
    def enable_whitelist(self):
        """Enable whitelist mode (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can enable whitelist")
        
        self.whitelist_enabled = True
        self.event("WhitelistEnabled")

    @public_function
    def disable_whitelist(self):
        """Disable whitelist mode (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can disable whitelist")
        
        self.whitelist_enabled = False
        self.event("WhitelistDisabled")

    @public_function
    def add_to_whitelist(self, account: str):
        """Add address to whitelist (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can modify whitelist")
        
        self.whitelist[account] = True
        self.event("AddedToWhitelist", account)

    @public_function
    def remove_from_whitelist(self, account: str):
        """Remove address from whitelist (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can modify whitelist")
        
        self.whitelist[account] = False
        self.event("RemovedFromWhitelist", account)

    @public_function
    def add_to_blacklist(self, account: str):
        """Add address to blacklist (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can modify blacklist")
        
        self.blacklist[account] = True
        self.event("AddedToBlacklist", account)

    @public_function
    def remove_from_blacklist(self, account: str):
        """Remove address from blacklist (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can modify blacklist")
        
        self.blacklist[account] = False
        self.event("RemovedFromBlacklist", account)

    # ============================================
    # PAUSABLE & EMERGENCY FUNCTIONS
    # ============================================

    @public_function
    def pause(self):
        """Pause vault operations (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can pause")
        
        if self.paused:
            raise Exception("Already paused")
        
        self.paused = True
        self.event("Paused", sender)

    @public_function
    def unpause(self):
        """Unpause vault operations (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can unpause")
        
        if not self.paused:
            raise Exception("Not paused")
        
        self.paused = False
        self.event("Unpaused", sender)

    @public_function
    def activate_emergency_mode(self):
        """
        Activate emergency mode (Owner only).
        Enables emergency withdrawals and disables deposits.
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can activate emergency mode")
        
        self.emergency_mode = True
        self.event("EmergencyModeActivated", sender)

    @public_function
    def deactivate_emergency_mode(self):
        """Deactivate emergency mode (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can deactivate emergency mode")
        
        self.emergency_mode = False
        self.event("EmergencyModeDeactivated", sender)

    # ============================================
    # OWNERSHIP FUNCTIONS
    # ============================================

    @public_function
    def transfer_ownership(self, new_owner: str):
        """Transfer ownership (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can transfer ownership")
        
        if new_owner == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot transfer to zero address")
        
        old_owner = self.owner
        self.owner = new_owner
        self.event("OwnershipTransferred", old_owner, new_owner)
