"""
AdvancedToken - Full-Featured ERC20 Token with All Extensions
Generated by Zero Wizard - Production Ready

Features:
- Complete ERC20 implementation
- Ownable (single owner access control)
- Mintable (create new tokens)
- Burnable (destroy tokens)
- Pausable (emergency pause)
- Allowance system
- Transfer restrictions
- Supply management
"""

from zerothan.py_contracts import PySmartContract

class AdvancedToken(PySmartContract):
    """
    Advanced ERC20-equivalent token with comprehensive features.
    
    This contract includes:
    - Full ERC20 standard (transfer, approve, transferFrom)
    - Owner-controlled minting
    - User-controlled burning
    - Emergency pause mechanism
    - Transfer restrictions
    - Event logging for all operations
    """
    
    def __init__(self):
        super().__init__()
        
        # Token metadata
        self.name = "Advanced Token"
        self.symbol = "ADV"
        self.decimals = 18
        
        # Core state variables
        self.total_supply = self.state_var("total_supply", 0)
        self.balances = self.state_var("balances", {})
        self.allowances = self.state_var("allowances", {})
        
        # Ownable state
        self.owner = self.state_var("owner", self.msg_sender())
        
        # Pausable state
        self.paused = self.state_var("paused", False)
        
        # Minting control
        self.minting_enabled = self.state_var("minting_enabled", True)
        self.max_supply = self.state_var("max_supply", 1000000000 * 10**18)  # 1 billion max
        
        # Transfer restrictions
        self.transfer_enabled = self.state_var("transfer_enabled", True)
        self.blacklist = self.state_var("blacklist", {})
        
        # Statistics
        self.total_minted = self.state_var("total_minted", 0)
        self.total_burned = self.state_var("total_burned", 0)
        self.holder_count = self.state_var("holder_count", 0)
        
        # Mint initial supply to owner
        initial_supply = 100000000 * 10**18  # 100 million
        self.balances[self.msg_sender()] = initial_supply
        self.total_supply = initial_supply
        self.total_minted = initial_supply
        self.holder_count = 1
        
        self.event("Transfer", "0x0000000000000000000000000000000000000000", self.msg_sender(), initial_supply)

    # ============================================
    # ERC20 STANDARD FUNCTIONS
    # ============================================

    @public_function
    def transfer(self, to: str, amount: int):
        """
        Transfer tokens to another address.
        
        Requirements:
        - Contract must not be paused
        - Transfers must be enabled
        - Sender must have sufficient balance
        - Recipient must not be blacklisted
        """
        sender = self.msg_sender()
        
        # Check if paused
        if self.paused:
            raise Exception("Token transfers are paused")
        
        # Check if transfers enabled
        if not self.transfer_enabled:
            raise Exception("Transfers are currently disabled")
        
        # Check blacklist
        if self.blacklist.get(sender, False):
            raise Exception("Sender is blacklisted")
        
        if self.blacklist.get(to, False):
            raise Exception("Recipient is blacklisted")
        
        # Check amount
        if amount <= 0:
            raise Exception("Amount must be positive")
        
        # Check balance
        sender_bal = self.balances.get(sender, 0)
        if sender_bal < amount:
            raise Exception("Insufficient balance")
        
        # Update balances
        recipient_bal = self.balances.get(to, 0)
        self.balances[sender] = sender_bal - amount
        self.balances[to] = recipient_bal + amount
        
        # Update holder count
        if recipient_bal == 0 and amount > 0:
            self.holder_count += 1
        
        if sender_bal == amount:
            self.holder_count -= 1
        
        self.event("Transfer", sender, to, amount)

    @public_function
    def approve(self, spender: str, amount: int):
        """
        Approve an address to spend tokens on your behalf.
        
        Requirements:
        - Spender cannot be zero address
        - Amount can be any value (including 0 to revoke)
        """
        sender = self.msg_sender()
        
        if spender == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot approve zero address")
        
        # Initialize nested dict if needed
        if sender not in self.allowances:
            self.allowances[sender] = {}
        
        self.allowances[sender][spender] = amount
        
        self.event("Approval", sender, spender, amount)

    @public_function
    def transfer_from(self, from_addr: str, to: str, amount: int):
        """
        Transfer tokens from one address to another using allowance.
        
        Requirements:
        - Contract must not be paused
        - Caller must have sufficient allowance
        - From address must have sufficient balance
        """
        sender = self.msg_sender()
        
        # Check if paused
        if self.paused:
            raise Exception("Token transfers are paused")
        
        # Check if transfers enabled
        if not self.transfer_enabled:
            raise Exception("Transfers are currently disabled")
        
        # Check blacklist
        if self.blacklist.get(from_addr, False):
            raise Exception("From address is blacklisted")
        
        if self.blacklist.get(to, False):
            raise Exception("To address is blacklisted")
        
        # Check allowance
        if from_addr not in self.allowances:
            raise Exception("No allowance set")
        
        current_allowance = self.allowances[from_addr].get(sender, 0)
        if current_allowance < amount:
            raise Exception("Insufficient allowance")
        
        # Check balance
        from_balance = self.balances.get(from_addr, 0)
        if from_balance < amount:
            raise Exception("Insufficient balance")
        
        # Update balances
        to_balance = self.balances.get(to, 0)
        self.balances[from_addr] = from_balance - amount
        self.balances[to] = to_balance + amount
        
        # Update allowance
        self.allowances[from_addr][sender] = current_allowance - amount
        
        # Update holder count
        if to_balance == 0 and amount > 0:
            self.holder_count += 1
        
        if from_balance == amount:
            self.holder_count -= 1
        
        self.event("Transfer", from_addr, to, amount)

    # ============================================
    # VIEW FUNCTIONS
    # ============================================

    @view_function
    def balance_of(self, owner: str) -> int:
        """Get the token balance of an address."""
        return self.balances.get(owner, 0)

    @view_function
    def allowance(self, owner: str, spender: str) -> int:
        """Get the allowance of a spender for an owner."""
        if owner not in self.allowances:
            return 0
        return self.allowances[owner].get(spender, 0)

    @view_function
    def get_total_supply(self) -> int:
        """Get the total token supply."""
        return self.total_supply

    @view_function
    def get_owner(self) -> str:
        """Get the contract owner."""
        return self.owner

    @view_function
    def is_paused(self) -> int:
        """Check if contract is paused (returns 1 for true, 0 for false)."""
        return 1 if self.paused else 0

    @view_function
    def is_blacklisted(self, account: str) -> int:
        """Check if an address is blacklisted."""
        return 1 if self.blacklist.get(account, False) else 0

    @view_function
    def get_holder_count(self) -> int:
        """Get the number of token holders."""
        return self.holder_count

    @view_function
    def get_total_minted(self) -> int:
        """Get the total amount of tokens ever minted."""
        return self.total_minted

    @view_function
    def get_total_burned(self) -> int:
        """Get the total amount of tokens ever burned."""
        return self.total_burned

    # ============================================
    # MINTING FUNCTIONS
    # ============================================

    @public_function
    def mint(self, to: str, amount: int):
        """
        Mint new tokens (Owner only).
        
        Requirements:
        - Caller must be owner
        - Minting must be enabled
        - Total supply must not exceed max supply
        - Amount must be positive
        """
        sender = self.msg_sender()
        
        # Only owner can mint
        if sender != self.owner:
            raise Exception("Only owner can mint")
        
        # Check if minting is enabled
        if not self.minting_enabled:
            raise Exception("Minting is disabled")
        
        # Check amount
        if amount <= 0:
            raise Exception("Amount must be positive")
        
        # Check max supply
        if self.total_supply + amount > self.max_supply:
            raise Exception("Would exceed max supply")
        
        # Mint tokens
        current_bal = self.balances.get(to, 0)
        self.balances[to] = current_bal + amount
        self.total_supply += amount
        self.total_minted += amount
        
        # Update holder count
        if current_bal == 0:
            self.holder_count += 1
        
        self.event("Transfer", "0x0000000000000000000000000000000000000000", to, amount)
        self.event("Mint", to, amount)

    @public_function
    def disable_minting(self):
        """
        Permanently disable minting (Owner only).
        This action cannot be undone!
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can disable minting")
        
        self.minting_enabled = False
        self.event("MintingDisabled", sender)

    # ============================================
    # BURNING FUNCTIONS
    # ============================================

    @public_function
    def burn(self, amount: int):
        """
        Burn your own tokens.
        
        Requirements:
        - Caller must have sufficient balance
        - Amount must be positive
        """
        sender = self.msg_sender()
        sender_bal = self.balances.get(sender, 0)
        
        if amount <= 0:
            raise Exception("Amount must be positive")
        
        if sender_bal < amount:
            raise Exception("Insufficient balance to burn")
        
        # Burn tokens
        self.balances[sender] = sender_bal - amount
        self.total_supply -= amount
        self.total_burned += amount
        
        # Update holder count
        if sender_bal == amount:
            self.holder_count -= 1
        
        self.event("Transfer", sender, "0x0000000000000000000000000000000000000000", amount)
        self.event("Burn", sender, amount)

    @public_function
    def burn_from(self, account: str, amount: int):
        """
        Burn tokens from another account (requires allowance).
        
        Requirements:
        - Caller must have sufficient allowance
        - Account must have sufficient balance
        """
        sender = self.msg_sender()
        
        # Check allowance
        if account not in self.allowances:
            raise Exception("No allowance set")
        
        current_allowance = self.allowances[account].get(sender, 0)
        if current_allowance < amount:
            raise Exception("Insufficient allowance")
        
        # Check balance
        account_bal = self.balances.get(account, 0)
        if account_bal < amount:
            raise Exception("Insufficient balance")
        
        # Burn tokens
        self.balances[account] = account_bal - amount
        self.total_supply -= amount
        self.total_burned += amount
        
        # Update allowance
        self.allowances[account][sender] = current_allowance - amount
        
        # Update holder count
        if account_bal == amount:
            self.holder_count -= 1
        
        self.event("Transfer", account, "0x0000000000000000000000000000000000000000", amount)
        self.event("Burn", account, amount)

    # ============================================
    # PAUSABLE FUNCTIONS
    # ============================================

    @public_function
    def pause(self):
        """
        Pause all token transfers (Owner only).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can pause")
        
        if self.paused:
            raise Exception("Already paused")
        
        self.paused = True
        self.event("Paused", sender)

    @public_function
    def unpause(self):
        """
        Unpause token transfers (Owner only).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can unpause")
        
        if not self.paused:
            raise Exception("Not paused")
        
        self.paused = False
        self.event("Unpaused", sender)

    # ============================================
    # TRANSFER CONTROL FUNCTIONS
    # ============================================

    @public_function
    def enable_transfers(self):
        """Enable token transfers (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can enable transfers")
        
        self.transfer_enabled = True
        self.event("TransfersEnabled", sender)

    @public_function
    def disable_transfers(self):
        """Disable token transfers (Owner only)."""
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can disable transfers")
        
        self.transfer_enabled = False
        self.event("TransfersDisabled", sender)

    # ============================================
    # BLACKLIST FUNCTIONS
    # ============================================

    @public_function
    def add_to_blacklist(self, account: str):
        """
        Add an address to the blacklist (Owner only).
        Blacklisted addresses cannot send or receive tokens.
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can blacklist")
        
        if account == self.owner:
            raise Exception("Cannot blacklist owner")
        
        self.blacklist[account] = True
        self.event("Blacklisted", account)

    @public_function
    def remove_from_blacklist(self, account: str):
        """
        Remove an address from the blacklist (Owner only).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can remove from blacklist")
        
        self.blacklist[account] = False
        self.event("RemovedFromBlacklist", account)

    # ============================================
    # OWNERSHIP FUNCTIONS
    # ============================================

    @public_function
    def transfer_ownership(self, new_owner: str):
        """
        Transfer ownership to a new address (Owner only).
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can transfer ownership")
        
        if new_owner == "0x0000000000000000000000000000000000000000":
            raise Exception("Cannot transfer to zero address")
        
        old_owner = self.owner
        self.owner = new_owner
        self.event("OwnershipTransferred", old_owner, new_owner)

    @public_function
    def renounce_ownership(self):
        """
        Renounce ownership (Owner only).
        WARNING: This will leave the contract without an owner!
        """
        sender = self.msg_sender()
        
        if sender != self.owner:
            raise Exception("Only owner can renounce ownership")
        
        old_owner = self.owner
        self.owner = "0x0000000000000000000000000000000000000000"
        self.event("OwnershipRenounced", old_owner)
